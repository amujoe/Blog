# vue3.x 
一个质变, 是一种飞跃. 哦! 不要太刺激咯



先来看看作者自己认为 3.0 的一些亮点:


- `Performance`：性能更比`Vue 2.0`强。
- `Tree shaking support`：可以将无用模块“剪辑”，仅打包需要的。
- `Composition API`：组合`API`
- `Fragment, Teleport, Suspense`：“碎片”，`Teleport`即`Protal传送门`，“悬念”
- `Better TypeScript support`：更优秀的Ts支持
- `Custom Renderer API`：暴露了自定义渲染`API`


## Composition——API
Composition 作文、构成、组合方式
Composition-API  合成API。 它是为了实现基于函数的逻辑复用机制而产生的。

Vue核心团队将组件Composition API描述为“一套附加的、基于函数的api，允许灵活地组合组件逻辑


## Options-API
在vue2中，我们会在一个vue文件中定义methods，computed，watch，data中等等属性和方法，共同处理页面逻辑,我们称这种方式为Options API
![](https://img-blog.csdnimg.cn/c7d09477e2fa47a9a51e947ccb7fd025.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5aW56L-Y5Lya5p2l5ZCX,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center)

优缺点
一个功能往往需要在不同的vue配置项中定义属性和方法，比较分散，项目小还好，清晰明了，但是项目大了后，一个methods中可能包含很多个方法，你往往分不清哪个方法对应着哪个功能
条例清晰,相同的放在相同的地方;但随着组件功能的增大,关联性会大大降低,组件的阅读和理解难度会增加

对比图
![对比图](https://pic2.zhimg.com/80/v2-3215832798dad4d85252c140e509f445_1440w.webp)

进一步拆解
![进一步拆解](https://pic3.zhimg.com/80/v2-7889c66d30a72bf92842103cf92ed84e_1440w.webp)

setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之前的函数



## reactive vs ref 区别

reactive:
(1)它的响应式是更加‘深层次’的，底层本质是将传入的数据包装成一个Proxy。
(2)参数必须是对象或者数组，如果要让对象的某个元素实现响应式时比较麻烦。需要使用toRefs
ref:
(1)函数参数可以是基本数据类型，也可以接受对象类型
(2)如果参数是对象类型时，其实底层的本质还是reactive,系统会自动根据我们给ref传入的值转换成：
ref(1)->reactive({value:1})
ref函数只能操作浅层次的数据，把基本数据类型当作自己的属性值；深层次依赖于reactive
复制代码
(3)在template中访问，系统会自动添加.value;在js中需要手动.value
(4)ref响应式原理是依赖于Object.defineProperty()的get()和set()的。



## ref、toRef、toRefs的区别

ref:复制，修改响应式数据不影响以前的数据；数据改变，界面自动更新

toRef:引用，修改响应式数据会影响以前的数据；数据改变，界面不自动更新

toRefs：
(1)接收一个对象作为参数，它会遍历对象身上所有属性，然后调用单个toRef
(2)将对象的多个属性变成响应式数据，并且要求响应式数据和原始数据关联，且更新响应式数据的时候不会更新界面，用于批量设置多个数据为响应式

作者：Rookie_coming
链接：https://juejin.cn/post/7013326406444646407
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。